"""This file contains functions which assist the creation, extraction and analysis of probability densities generated by plumed reading a COLVAR file and a class for general purpose plumed data file manipulation in python
"""

import subprocess
import os
import numpy as np

# This file contains a class that is allows easy manipulation of plumed data files in python
class plumed_file:
    """Parses and stores a plumed data file for manipulation
    
    Parameters:
    ---
    **filename: *str* **
    The name of the plumed data file to parse"""
    
    def __init__(self, filename):
        self.filename = filename
        with open(filename, 'r') as file:
            data = file.readlines()
            self.data = self.parser(data)
            
    def parser(self, data):
        """
        Parses file into a 2d array where rows correspond to lines in the file and columns contain a description of the line, its name and its contents. 

        Parameters:
        ---
        **filename: *str* **  
        The name of the histogram file to read

        Returns:
        ---
        **data: *ndarray* **   
        An array containing all of the histograms data parsed and formatted
        
        Notes
        ---
        Once a file is parsed it will generally be a 2d array of the form: [[description, name, arguements], [description, name, arguements], ...]. 
        The exact format the parser uses is detailed below.
        A line generally has the format [description, name, arguement1, arguement2, ...]. The only exception is 'empty' lines which only contain a description.
        
        There are seven different descriptions a line can have, ['action_start', 'action_end', 'action_var', 'action_single', 'variable', 'empty', 'comment'].
        
        The 'action_start' and 'action_end' descriptions indicate the line marks the start or end of a multiline action
        .
        The 'action_var' description indicates the line describes an arguement of a multiline action
        
        The 'action_single' description indicates the line contains an entire action on a single line, including declaration and arguements
        
        The 'variable' description indicates the line which stores the result of an action into a variable
        
        The 'empty' description indicates the line contains nothing (is just for formatting)
        
        The 'comment' description indicates the line contains only a comment and nothing else
        
        For more information on actions see the Plumed documentation
        
        The name column contains information to distinguish lines with the same description.
        
        Lines with the description 'action_start' and 'action_single' have the name of the action as their name column
        
        Lines with the description 'action_end' have '...' in their name column
        
        Lines with the description 'variable' have the name of the variable they're using in their name column
        
        Lines with the description 'comment' are simply numbered in the order in which they appear, starting from 0, in their name column.
        
        Anything else on a line that is not written in the name column is placed in arguements columns. Arguements can contain several columns. Every string which is seperated by a space is placed in its own column in arguements.
        
        Examples
        ---
        In this example the file called 'plumed.dat' contains the following two lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR']]
        """
        
        inside_action = ''
        
        for i in range(len(data)):
            line = data[i].strip()
            
            if not line:
                data[i] = ['empty']
                continue
                
            elif '#' == line.split()[0]:
                data[i] = ['comment', f'{i}', line]
                continue
            
            elif inside_action:
                if '...' in line.split():
                    descriptor = 'action_end'
                    name, args = line.split()
                    inside_action = ''
                    
                else:
                    descriptor = 'action_var'
                    name, args = inside_action, line
                    
            else:
                if '...' in line.split():
                    descriptor = 'action_start'
                    name, args = line.split()
                    inside_action = name
                    
                elif ':' in line:
                    descriptor = 'variable'
                    name, args = line.split(':')

                else:
                    descriptor = 'action_single'
                    name, args = line.split()[0], ' '.join(line.split()[1:])

            args = args.strip().split()
            data[i] = [descriptor, name]
            data[i].extend(args)           
                
        return data
    
    def reparse(self):
        """For use after adding data to the file, parses it to match the rest of the data.
        Modifies `self.data`.
        
        See Also
        ---
        parser: Main function used for parsing
        """
        
        inside_action = ''
        
        for line_num in range(len(self.data)):
            line = self.data[line_num]
            if isinstance(line, str):
                if inside_action:
                    parsed_line = ['action_var', inside_action, line]
                    
                else:
                    parsed_line = self.parser([line])[0]
                    
                self.data[line_num] = parsed_line
                    
            elif line[0] == 'action_start':
                inside_action = line[1]

            elif line[0] == 'action_end':
                inside_action = ''
                    
    def findbyname(self, descriptors):
        """Finds and returns the line_number of the first line matching the given set of descriptors.
        Intended for being use by other methods.
        
        Parameters:
        ---
        **descriptors: *list* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

        Returns:
        ---
        **line_num: *int* **   
        The line number (i.e. its index in self.data) of the desired line, if a line is found
        
        **None**
        If no matching line is found, None is returned
        
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        In this example we wish to have findbyname return the third line to us (which is line number 2 when counting from 0)
        If the entire parsed line is passed to findbyname then the line number of that exact line is returned
        
        >>> file1.findbyname(['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR'])
        2
        
        However only enough information to uniquely identify the line is needed, the following also correctly identifies the line
        
        >>> file1.findbyname(['action_single', 'PRINT', 'ARG=d1'])
        2
        
        If too little information is passed then it becomes ambiguous which line is being reffered to leading to (possibly) the wrong line number being returned, as below 
        
        >>> file1.findbyname(['action_single', 'PRINT'])
        1
        
        
        """
        num_d = len(descriptors)
        for line_num in range(len(self.data)):
            line = self.data[line_num]
            match = 1
            if num_d > len(line):
                match = 0
            else:
                for index in range(2): # The first two descriptors, line_type and name, must match exactly
                    if descriptors[index] != line[index]:
                        match = 0
                for index in range(2, num_d): # The remaining descriptors, which are arguements of the action, use a less strict matching
                    if descriptors[index] not in line[index]:
                        match = 0
                    
            if match:
                return line_num
                
        return
                
    def modify(self, line, key, value):
        """Modifies one element of a given parsed line and returns it. 
        Do not call directly, instead use the `modify_line` method
        
        Parameters:
        ---
        **line: *list* **  
        The parsed form of a line, usually directly obtained from self.data
        
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **value: *str* **  
        The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced

        Returns:
        ---
        **line: *list* **   
        The modified version of the line, with one element replaced. If `key` was not found, then this will be the original line.
        
        See Also:
        ---
        
        modify_line: A method for modifying a line based on its contents or line number
        
        """
        
        for section_num in range(len(line)):
            section = line[section_num]
            if key in section:
                if '=' in section:
                    section = section.split('=')
                    section[1] = value
                    section = '='.join(section)
                else:
                    section = value

                line[section_num] = section
                return line
        return line # If no match is found return the original line
    
    def modify_line(self, key, value, line_num=None, descriptors=None):
        """Modifies an element of a line.
        The line can be found either by specifying its line number or describing its contents. This method modifies `self.data
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **value: *str* **  
        The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.modify_line('PRINT', 'DUMP', descriptors=['action_single', 'PRINT', 'ARG=d1'])
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'DUMP', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.modify_line('STRIDE', '500', line_num=1)
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=500', 'FILE=COLVAR'], ['action_single', 'DUMP', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        """
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            line = self.modify(line, key, value)
            self.data[line_num] = line
                
    def remove_line(self, line_num=None, descriptors=None):
        """Remove a line specified by its line number or a description of its contents.
        
        Parameters:
        ---
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.remove_line(descriptors=['action_single', 'PRINT', 'ARG=d1'])
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR']]

        >>> file1.remove_line(line_num=1)
        >>> file1.data        
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306']]
        
        """
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            del self.data[line_num]
        else:
            pass
        
    def remove_arg(self, key, line_num=None, descriptors=None):
        """Remove an arguement from a line specified by its line number or a description of its contents. 
        The arguement is specified by its `key`, eg 'STRIDE'. However if the key appears multiple times only the first instance will be removed. 
        If key appears as a substring in a previous arguement that arguement will be removed instead.
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.remove_arg('FILE', descriptors=['action_single'N, 'PRINT', 'ARG=d1'])
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100']]
        
        >>> file1.remove_arg('STRIDE', line_num=1)
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100']]
        """
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            for section_num in range(len(line)):
                if key in line[section_num]:
                    del line[section_num]
                    self.data[line_num] = line
                    return
        else:
            pass
                
                
    def add_line(self, line, line_num=None, descriptors=None):
        """Adds a line to the file so that it has a particular line number or after a line specified by a description of its contents.
        
        Parameters:
        ---
        **line: *str* **  
        A string containing the line as it would appear in the plumed data file
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following line
        
        d1: DISTANCE ATOMS=301,306
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306']]
        
        >>> file1.add_line('PRINT ARG=d1 STRIDE=100 FILE=COLVAR', line_num=1)
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.add_line('PRINT ARG=* STRIDE=100 FILE=COLVAR', descriptors=['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'])
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        """
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            if isinstance(line_num, int):
                line_num += 1
          
        if isinstance(line_num, int):
            self.data.insert(line_num, line)
            self.reparse()
            
    def add_parsed(self, line, line_num=-1, descriptors=None):
        """Adds a parsed line to the file at the given line number (default at the end) or after a line specified by a description of its contents.
        
        Parameters:
        ---
        **line: *list* **  
        The parsed form of a line to be added to the file
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following line
        
        d1: DISTANCE ATOMS=301,306
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306']]
        
        >>> file1.add_parsed(['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR'], line_num=1)
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.add_parsed(['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], descriptors=['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'])
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        """
          
        if descriptors:
            line_num = self.findbyname(descriptors)
            if isinstance(line_num, int):
                line_num += 1
            
        if isinstance(line_num, int):
            if line_num == -1:
                self.data.append(line_num, line)
            else:
                self.data.insert(line_num, line)
        
    def add_arg(self, arg, line_num=None, descriptors=None):
        """Adds an additional arguement to a line specified by either line_number or by a description of its contents
        
        Parameters:
        ---
        **arg: *str* **  
        The arguement to be added to the line
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following line
        
        PRINT ARG=d1
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['action_single', 'PRINT', 'ARG=d1']]
        
        >>> file1.add_arg('STRIDE=100', line_num=0)
        >>> file1.data
        [['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100']]
        
        >>> file1.add_arg('FILE=COLVAR', descriptors=['action_single', 'PRINT'])
        >>> file1.data
        [['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

        """

        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            self.data[line_num].append(arg)
            
    def get_line(self, line_num=None, descriptors=None):
        """Get a line specified by its line number or by a description of its contents.
        
        Parameters:
        ---
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be retrieved.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Returns:
        ---
        **self.data[line_num]: *list* **
        The requested line in the parsed format
        
        **None**
        If no match is found
        
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'] ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.get_line(descriptors=['action_single', 'PRINT', 'ARG=d1'])
        ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']

        >>> file1.get_line(line_num=1)  
        ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR']
        """
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            return self.data[line_num]
        else:
            return None
        
    def get_arg(self, key, line_num=None, descriptors=None):
        """Get first matching arguement in a line
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to retrieve. This method looks for which element of the line contains `key`
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line from which the arguement will be retrieved.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Returns:
        ---
        **line[section_num]: *str* **
        The requested arguement
        
        **None**
        If no match is found
        
        Examples:
        ---
        In this example the file called 'plumed.dat' contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        >>> file1 = plumed_file('plumed.dat')
        >>> file1.data
        [['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'] ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
        
        >>> file1.get_arg('STRIDE', descriptors=['action_single', 'PRINT', 'ARG=d1'])
        'STRIDE=100'

        >>> file1.get_arg('FILE', line_num=1)  
        'FILE=COLVAR'

        """
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            for section_num in range(len(line)):
                if key in line[section_num]:
                    return line[section_num]
        else:
            return None
        
    
    def save(self, filename=''):
        """Saves all changes to the file.
        
        Parameters:
        ---
        **filename: *str, optional* **  
        The filename to use when saving. By default overwrites the file used to create this object
        
        """
        if not filename:
            filename = self.filename
            
        plain_data = []
        for line in self.data:
            line = list(line)
            if line[0] == 'variable':
                line[1] = line[1] + ':'
                
            elif line[0] == 'action_var':
                line[2] = ' ' + line[2]
                del line[0]
                
            elif line[0] == 'comment':
                del line[1]
                
            del line[0]
            plain_data.append(' '.join(line) + '\n')
        
        with open(filename, 'w+') as file:
            file.writelines(plain_data)
        


def plumed_histo(filename, maxbackup=100, out=True):
    """For running a plumed script which creates histograms.  
    Has options to set `maxbackup` which is usually needed when creating many files.

    Parameters:
    ---
    **filename: *str* **  
    The name of the plumed data file to use

    **maxbackup: *int, optional* **  
    The maximum amount of backups and hence files plumed is allowed to create

    **out: *bool, optional* **  
    When set to True the function will print its output (what would normally appear in the shell)."""
    
    bashCommand = f"plumed --no-mpi driver --plumed {filename} --noatoms"
    env_set = f'export PLUMED_MAXBACKUP={maxbackup}'
    normal = subprocess.run(env_set + '; ' + bashCommand,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        check=True,
        text=True,
        shell=True
        )

    if out:
        print(normal.stdout)
    
def import_histo(filename):
    """Reads in a histogram file, normalises the values and returns a numpy float array

    Parameters:
    ---
    **filename: *str* **  
    The name of the histogram file to read

    Returns:
    ---
    **data: *ndarray* **   
    An array containing all of the histograms data"""
    
    with open(filename, 'r') as file:
        data = file.readlines()
    normalisation = float(data[1].split()[3])
    data = data[6:]
    for i in range(len(data)):
        data[i] = [float(num) for num in data[i].split()]
    data = np.array(data)
    data[:,1] = data[:,1]/normalisation
    return data

def create_histos(filename, steps, diff_steps, meta_file, histo_file, extra=0, max_modifier=1):
    """Creates histograms from a simulation which was restarted from another simulation, dumping the historgram data periodically.  
    The histograms are named by plumed using the format analysis.{i}.filename, where filename is specified in `histo_file` and {i} is a number indicating this is the i'th histogram created

    Parameters:
    ---
    **filename: *str* **  
    Name of the COLVAR file which contains the original sim and restarted sim

    **steps: *int* **  
    Number of steps which the restarted simulation ran for.

    **diff_steps: *int* **
    How often to dump the histogram data, defined in number of steps

    **meta_file: *pl_file* **  
    The plumed_file object which was used to perform metadynamics

    **histo_file: *pl_file* **  
    The plumed_file object which will be used to create the histograms

    **extra: *int, optional* **  
    The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.  
    For example extra=10 would include the final 10 steps of the original simulation.

    **max_modifier: *int, optional* **  
    The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.

    Returns:
    ---
    **start_num: *int* **  
    An integer which signifies the number in the filename of the first histogram pertaining to the restarted simulation. This will be 0 if extra is not specified

    **end_num: *int* **  
    An integer which signifies the number in the filename of the final histogram pertaining to the restarted simulation. This is also the total number of histograms created"""
    
    with open(filename, 'r') as file:
        data = file.readlines()

    meta_stride = meta_file.get_arg('STRIDE', descriptors=['action_single', 'PRINT'])
    meta_stride = int(meta_stride.split('=')[1])
    
    lines = round(steps/meta_stride) # Number of lines in COLVAR file
    diff_stride = round(diff_steps/meta_stride) # Stride to use in histo_file
    file_num = int(lines/diff_stride) # Number of relevant files that will be generated
    
    extra_lines = round(extra/meta_stride)
    total_files = int((lines+extra_lines)/diff_stride) # Total number of generated files
    
    if extra_lines + lines > len(data)-2:
        raise Exception(f"Error: The number of lines requested {extra_lines + lines} is greater than the length of the provided file {len(data)-2}")
    
    del data[1:len(data)-lines-extra_lines-2]
    
    # Writing simulation of interest into its own file for running plumed on it
    with open("COLVAR_temp", "w+") as file:
        file.writelines(data)
    
    # Creating histograms for the simulation of interest
    histo_file.modify_line('STRIDE', str(diff_stride), descriptors=['action_single', 'DUMPGRID'])
    histo_file.save()
    plumed_histo(histo_file.filename, maxbackup=total_files*max_modifier, out=False)
    
    os.remove("COLVAR_temp") # Cleanup
    
    start_num = total_files - file_num - 1
    end_num = total_files - 2
    return start_num, end_num # The number in the filename of the first and last relevant (i.e. pertaining to the restarted simulation) files 

def analyse_pd(filename, steps, diff_steps, meta_file, histo_file, analyser=lambda x:x, extra=0, clean_up=True):
    """Computes the probability densities at set intervals over a simulation, then analyses these probability densities. 
    A list is returned containing the result of each time analyser was run.
    
    Parameters:
    ---
    **filename: *str* **  
    Name of the COLVAR file which contains the original sim and restarted sim

    **steps: *int* **  
    Number of steps which the restarted simulation ran for.

    **diff_steps: *int* **  
    How often to dump the histogram data, defined in number of steps

    **meta_file: *pl_file* **  
    The plumed_file object which was used to perform metadynamics

    **histo_file: *pl_file* **  
    The plumed_file object which will be used to create the histograms

    **analyser: *callable, optional* **  
    The function which will be run on each histogram to analyse it, and whose output is stored in `output`

    **extra: *int, optional* **  
    The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.  
    For example extra=10 would include the final 10 steps of the original simulation.

    **max_modifier: *int, optional* **  
    The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.

    Returns:
    ---
    **output: *list* **  
    A list containing the results of running `analyser` on each histogram"""
    
    start, end = create_histos(filename, steps, diff_steps, meta_file, histo_file, extra=extra)

    output = []
    count = 0
    
    if not extra:
        histogram = import_histo("histo")
        output.append(analyser(histogram))
        
    if clean_up:
        os.remove("histo")
    for i in range(0, end+1):    
        if i >= start:
            histogram = import_histo(f"analysis.{i}.histo")
            output.append(analyser(histogram))  
        if clean_up:
            os.remove(f"analysis.{i}.histo")
    return output
