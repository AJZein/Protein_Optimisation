<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>plumed_helpers API documentation</title>
<meta name="description" content="This file contains functions which assist the creation, extraction and analysis of probability densities generated by plumed reading a COLVAR file and â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>plumed_helpers</code></h1>
</header>
<section id="section-intro">
<p>This file contains functions which assist the creation, extraction and analysis of probability densities generated by plumed reading a COLVAR file and a class for general purpose plumed data file manipulation in python</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This file contains functions which assist the creation, extraction and analysis of probability densities generated by plumed reading a COLVAR file and a class for general purpose plumed data file manipulation in python
&#34;&#34;&#34;

import subprocess
import os
import numpy as np

# This file contains a class that is allows easy manipulation of plumed data files in python
class plumed_file:
    &#34;&#34;&#34;Parses and stores a plumed data file for manipulation
    
    Parameters:
    ---
    **filename: *str* **
    The name of the plumed data file to parse&#34;&#34;&#34;
    
    def __init__(self, filename):
        self.filename = filename
        with open(filename, &#39;r&#39;) as file:
            data = file.readlines()
            self.data = self.parser(data)
            
    def parser(self, data):
        &#34;&#34;&#34;
        Parses file into a 2d array where rows correspond to lines in the file and columns contain a description of the line, its name and its contents. 

        Parameters:
        ---
        **filename: *str* **  
        The name of the histogram file to read

        Returns:
        ---
        **data: *ndarray* **   
        An array containing all of the histograms data parsed and formatted
        
        Notes
        ---
        Once a file is parsed it will generally be a 2d array of the form: [[description, name, arguements], [description, name, arguements], ...]. 
        The exact format the parser uses is detailed below.
        A line generally has the format [description, name, arguement1, arguement2, ...]. The only exception is &#39;empty&#39; lines which only contain a description.
        
        There are seven different descriptions a line can have, [&#39;action_start&#39;, &#39;action_end&#39;, &#39;action_var&#39;, &#39;action_single&#39;, &#39;variable&#39;, &#39;empty&#39;, &#39;comment&#39;].
        
        The &#39;action_start&#39; and &#39;action_end&#39; descriptions indicate the line marks the start or end of a multiline action
        .
        The &#39;action_var&#39; description indicates the line describes an arguement of a multiline action
        
        The &#39;action_single&#39; description indicates the line contains an entire action on a single line, including declaration and arguements
        
        The &#39;variable&#39; description indicates the line which stores the result of an action into a variable
        
        The &#39;empty&#39; description indicates the line contains nothing (is just for formatting)
        
        The &#39;comment&#39; description indicates the line contains only a comment and nothing else
        
        For more information on actions see the Plumed documentation
        
        The name column contains information to distinguish lines with the same description.
        
        Lines with the description &#39;action_start&#39; and &#39;action_single&#39; have the name of the action as their name column
        
        Lines with the description &#39;action_end&#39; have &#39;...&#39; in their name column
        
        Lines with the description &#39;variable&#39; have the name of the variable they&#39;re using in their name column
        
        Lines with the description &#39;comment&#39; are simply numbered in the order in which they appear, starting from 0, in their name column.
        
        Anything else on a line that is not written in the name column is placed in arguements columns. Arguements can contain several columns. Every string which is seperated by a space is placed in its own column in arguements.
        
        Examples
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following two lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        &#34;&#34;&#34;
        
        inside_action = &#39;&#39;
        
        for i in range(len(data)):
            line = data[i].strip()
            
            if not line:
                data[i] = [&#39;empty&#39;]
                continue
                
            elif &#39;#&#39; == line.split()[0]:
                data[i] = [&#39;comment&#39;, f&#39;{i}&#39;, line]
                continue
            
            elif inside_action:
                if &#39;...&#39; in line.split():
                    descriptor = &#39;action_end&#39;
                    name, args = line.split()
                    inside_action = &#39;&#39;
                    
                else:
                    descriptor = &#39;action_var&#39;
                    name, args = inside_action, line
                    
            else:
                if &#39;...&#39; in line.split():
                    descriptor = &#39;action_start&#39;
                    name, args = line.split()
                    inside_action = name
                    
                elif &#39;:&#39; in line:
                    descriptor = &#39;variable&#39;
                    name, args = line.split(&#39;:&#39;)

                else:
                    descriptor = &#39;action_single&#39;
                    name, args = line.split()[0], &#39; &#39;.join(line.split()[1:])

            args = args.strip().split()
            data[i] = [descriptor, name]
            data[i].extend(args)           
                
        return data
    
    def reparse(self):
        &#34;&#34;&#34;For use after adding data to the file, parses it to match the rest of the data.
        Modifies `self.data`.
        
        See Also
        ---
        parser: Main function used for parsing
        &#34;&#34;&#34;
        
        inside_action = &#39;&#39;
        
        for line_num in range(len(self.data)):
            line = self.data[line_num]
            if isinstance(line, str):
                if inside_action:
                    parsed_line = [&#39;action_var&#39;, inside_action, line]
                    
                else:
                    parsed_line = self.parser([line])[0]
                    
                self.data[line_num] = parsed_line
                    
            elif line[0] == &#39;action_start&#39;:
                inside_action = line[1]

            elif line[0] == &#39;action_end&#39;:
                inside_action = &#39;&#39;
                    
    def findbyname(self, descriptors):
        &#34;&#34;&#34;Finds and returns the line_number of the first line matching the given set of descriptors.
        Intended for being use by other methods.
        
        Parameters:
        ---
        **descriptors: *list* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

        Returns:
        ---
        **line_num: *int* **   
        The line number (i.e. its index in self.data) of the desired line, if a line is found
        
        **None**
        If no matching line is found, None is returned
        
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        In this example we wish to have findbyname return the third line to us (which is line number 2 when counting from 0)
        If the entire parsed line is passed to findbyname then the line number of that exact line is returned
        
        &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;])
        2
        
        However only enough information to uniquely identify the line is needed, the following also correctly identifies the line
        
        &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        2
        
        If too little information is passed then it becomes ambiguous which line is being reffered to leading to (possibly) the wrong line number being returned, as below 
        
        &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;])
        1
        
        
        &#34;&#34;&#34;
        num_d = len(descriptors)
        for line_num in range(len(self.data)):
            line = self.data[line_num]
            match = 1
            if num_d &gt; len(line):
                match = 0
            else:
                for index in range(2): # The first two descriptors, line_type and name, must match exactly
                    if descriptors[index] != line[index]:
                        match = 0
                for index in range(2, num_d): # The remaining descriptors, which are arguements of the action, use a less strict matching
                    if descriptors[index] not in line[index]:
                        match = 0
                    
            if match:
                return line_num
                
        return
                
    def modify(self, line, key, value):
        &#34;&#34;&#34;Modifies one element of a given parsed line and returns it. 
        Do not call directly, instead use the `modify_line` method
        
        Parameters:
        ---
        **line: *list* **  
        The parsed form of a line, usually directly obtained from self.data
        
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **value: *str* **  
        The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced

        Returns:
        ---
        **line: *list* **   
        The modified version of the line, with one element replaced. If `key` was not found, then this will be the original line.
        
        See Also:
        ---
        
        modify_line: A method for modifying a line based on its contents or line number
        
        &#34;&#34;&#34;
        
        for section_num in range(len(line)):
            section = line[section_num]
            if key in section:
                if &#39;=&#39; in section:
                    section = section.split(&#39;=&#39;)
                    section[1] = value
                    section = &#39;=&#39;.join(section)
                else:
                    section = value

                line[section_num] = section
                return line
        return line # If no match is found return the original line
    
    def modify_line(self, key, value, line_num=None, descriptors=None):
        &#34;&#34;&#34;Modifies an element of a line.
        The line can be found either by specifying its line number or describing its contents. This method modifies `self.data
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **value: *str* **  
        The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.modify_line(&#39;PRINT&#39;, &#39;DUMP&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;DUMP&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.modify_line(&#39;STRIDE&#39;, &#39;500&#39;, line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=500&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;DUMP&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            line = self.modify(line, key, value)
            self.data[line_num] = line
                
    def remove_line(self, line_num=None, descriptors=None):
        &#34;&#34;&#34;Remove a line specified by its line number or a description of its contents.
        
        Parameters:
        ---
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.remove_line(descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]

        &gt;&gt;&gt; file1.remove_line(line_num=1)
        &gt;&gt;&gt; file1.data        
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
        
        &#34;&#34;&#34;
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            del self.data[line_num]
        else:
            pass
        
    def remove_arg(self, key, line_num=None, descriptors=None):
        &#34;&#34;&#34;Remove an arguement from a line specified by its line number or a description of its contents. 
        The arguement is specified by its `key`, eg &#39;STRIDE&#39;. However if the key appears multiple times only the first instance will be removed. 
        If key appears as a substring in a previous arguement that arguement will be removed instead.
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.remove_arg(&#39;FILE&#39;, descriptors=[&#39;action_single&#39;N, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
        
        &gt;&gt;&gt; file1.remove_arg(&#39;STRIDE&#39;, line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            for section_num in range(len(line)):
                if key in line[section_num]:
                    del line[section_num]
                    self.data[line_num] = line
                    return
        else:
            pass
                
                
    def add_line(self, line, line_num=None, descriptors=None):
        &#34;&#34;&#34;Adds a line to the file so that it has a particular line number or after a line specified by a description of its contents.
        
        Parameters:
        ---
        **line: *str* **  
        A string containing the line as it would appear in the plumed data file
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following line
        
        d1: DISTANCE ATOMS=301,306
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
        
        &gt;&gt;&gt; file1.add_line(&#39;PRINT ARG=d1 STRIDE=100 FILE=COLVAR&#39;, line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.add_line(&#39;PRINT ARG=* STRIDE=100 FILE=COLVAR&#39;, descriptors=[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            if isinstance(line_num, int):
                line_num += 1
          
        if isinstance(line_num, int):
            self.data.insert(line_num, line)
            self.reparse()
            
    def add_parsed(self, line, line_num=-1, descriptors=None):
        &#34;&#34;&#34;Adds a parsed line to the file at the given line number (default at the end) or after a line specified by a description of its contents.
        
        Parameters:
        ---
        **line: *list* **  
        The parsed form of a line to be added to the file
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following line
        
        d1: DISTANCE ATOMS=301,306
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
        
        &gt;&gt;&gt; file1.add_parsed([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.add_parsed([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], descriptors=[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &#34;&#34;&#34;
          
        if descriptors:
            line_num = self.findbyname(descriptors)
            if isinstance(line_num, int):
                line_num += 1
            
        if isinstance(line_num, int):
            if line_num == -1:
                self.data.append(line_num, line)
            else:
                self.data.insert(line_num, line)
        
    def add_arg(self, arg, line_num=None, descriptors=None):
        &#34;&#34;&#34;Adds an additional arguement to a line specified by either line_number or by a description of its contents
        
        Parameters:
        ---
        **arg: *str* **  
        The arguement to be added to the line
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following line
        
        PRINT ARG=d1
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;]]
        
        &gt;&gt;&gt; file1.add_arg(&#39;STRIDE=100&#39;, line_num=0)
        &gt;&gt;&gt; file1.data
        [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
        
        &gt;&gt;&gt; file1.add_arg(&#39;FILE=COLVAR&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]

        &#34;&#34;&#34;

        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            self.data[line_num].append(arg)
            
    def get_line(self, line_num=None, descriptors=None):
        &#34;&#34;&#34;Get a line specified by its line number or by a description of its contents.
        
        Parameters:
        ---
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be retrieved.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Returns:
        ---
        **self.data[line_num]: *list* **
        The requested line in the parsed format
        
        **None**
        If no match is found
        
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;] [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.get_line(descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]

        &gt;&gt;&gt; file1.get_line(line_num=1)  
        [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            return self.data[line_num]
        else:
            return None
        
    def get_arg(self, key, line_num=None, descriptors=None):
        &#34;&#34;&#34;Get first matching arguement in a line
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to retrieve. This method looks for which element of the line contains `key`
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line from which the arguement will be retrieved.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Returns:
        ---
        **line[section_num]: *str* **
        The requested arguement
        
        **None**
        If no match is found
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;] [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.get_arg(&#39;STRIDE&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &#39;STRIDE=100&#39;

        &gt;&gt;&gt; file1.get_arg(&#39;FILE&#39;, line_num=1)  
        &#39;FILE=COLVAR&#39;

        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            for section_num in range(len(line)):
                if key in line[section_num]:
                    return line[section_num]
        else:
            return None
        
    
    def save(self, filename=&#39;&#39;):
        &#34;&#34;&#34;Saves all changes to the file.
        
        Parameters:
        ---
        **filename: *str, optional* **  
        The filename to use when saving. By default overwrites the file used to create this object
        
        &#34;&#34;&#34;
        if not filename:
            filename = self.filename
            
        plain_data = []
        for line in self.data:
            line = list(line)
            if line[0] == &#39;variable&#39;:
                line[1] = line[1] + &#39;:&#39;
                
            elif line[0] == &#39;action_var&#39;:
                line[2] = &#39; &#39; + line[2]
                del line[0]
                
            del line[0]
            plain_data.append(&#39; &#39;.join(line) + &#39;\n&#39;)
        
        with open(filename, &#39;w+&#39;) as file:
            file.writelines(plain_data)
        


def plumed_histo(filename, maxbackup=100, out=True):
    &#34;&#34;&#34;For running a plumed script which creates histograms.  
    Has options to set `maxbackup` which is usually needed when creating many files.

    Parameters:
    ---
    **filename: *str* **  
    The name of the plumed data file to use

    **maxbackup: *int, optional* **  
    The maximum amount of backups and hence files plumed is allowed to create

    **out: *bool, optional* **  
    When set to True the function will print its output (what would normally appear in the shell).&#34;&#34;&#34;
    
    bashCommand = f&#34;plumed --no-mpi driver --plumed {filename} --noatoms&#34;
    env_set = f&#39;export PLUMED_MAXBACKUP={maxbackup}&#39;
    normal = subprocess.run(env_set + &#39;; &#39; + bashCommand,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        check=True,
        text=True,
        shell=True
        )

    if out:
        print(normal.stdout)
    
def import_histo(filename):
    &#34;&#34;&#34;Reads in a histogram file, normalises the values and returns a numpy float array

    Parameters:
    ---
    **filename: *str* **  
    The name of the histogram file to read

    Returns:
    ---
    **data: *ndarray* **   
    An array containing all of the histograms data&#34;&#34;&#34;
    
    with open(filename, &#39;r&#39;) as file:
        data = file.readlines()
    normalisation = float(data[1].split()[3])
    data = data[6:]
    for i in range(len(data)):
        data[i] = [float(num) for num in data[i].split()]
    data = np.array(data)
    data[:,1] = data[:,1]/normalisation
    return data

def create_histos(filename, steps, diff_steps, meta_file, histo_file, extra=0, max_modifier=1):
    &#34;&#34;&#34;Creates histograms from a simulation which was restarted from another simulation, dumping the historgram data periodically.  
    The histograms are named by plumed using the format analysis.{i}.filename, where filename is specified in `histo_file` and {i} is a number indicating this is the i&#39;th histogram created

    Parameters:
    ---
    **filename: *str* **  
    Name of the COLVAR file which contains the original sim and restarted sim

    **steps: *int* **  
    Number of steps which the restarted simulation ran for.

    **diff_steps: *int* **
    How often to dump the histogram data, defined in number of steps

    **meta_file: *pl_file* **  
    The plumed_file object which was used to perform metadynamics

    **histo_file: *pl_file* **  
    The plumed_file object which will be used to create the histograms

    **extra: *int, optional* **  
    The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.  
    For example extra=10 would include the final 10 steps of the original simulation.

    **max_modifier: *int, optional* **  
    The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.

    Returns:
    ---
    **start_num: *int* **  
    An integer which signifies the number in the filename of the first histogram pertaining to the restarted simulation. This will be 0 if extra is not specified

    **end_num: *int* **  
    An integer which signifies the number in the filename of the final histogram pertaining to the restarted simulation. This is also the total number of histograms created&#34;&#34;&#34;
    
    with open(filename, &#39;r&#39;) as file:
        data = file.readlines()

    meta_stride = meta_file.get_arg(&#39;STRIDE&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;])
    meta_stride = int(meta_stride.split(&#39;=&#39;)[1])
    
    lines = round(steps/meta_stride) # Number of lines in COLVAR file
    diff_stride = round(diff_steps/meta_stride) # Stride to use in histo_file
    file_num = int(lines/diff_stride) # Number of relevant files that will be generated
    
    extra_lines = round(extra/meta_stride)
    total_files = int((lines+extra_lines)/diff_stride) # Total number of generated files
    
    if extra_lines + lines &gt; len(data)-2:
        raise Exception(f&#34;Error: The number of lines requested {extra_lines + lines} is greater than the length of the provided file {len(data)-2}&#34;)
    
    del data[1:len(data)-lines-extra_lines-2]
    
    # Writing simulation of interest into its own file for running plumed on it
    with open(&#34;COLVAR_temp&#34;, &#34;w+&#34;) as file:
        file.writelines(data)
    
    # Creating histograms for the simulation of interest
    histo_file.modify_line(&#39;STRIDE&#39;, str(diff_stride), descriptors=[&#39;action_single&#39;, &#39;DUMPGRID&#39;])
    histo_file.save()
    plumed_histo(histo_file.filename, maxbackup=total_files*max_modifier, out=False)
    
    os.remove(&#34;COLVAR_temp&#34;) # Cleanup
    
    start_num = total_files - file_num - 1
    end_num = total_files - 2
    return start_num, end_num # The number in the filename of the first and last relevant (i.e. pertaining to the restarted simulation) files 

def analyse_pd(filename, steps, diff_steps, meta_file, histo_file, analyser=lambda x:x, extra=0, clean_up=True):
    &#34;&#34;&#34;Computes the probability densities at set intervals over a simulation, then analyses these probability densities. 
    A list is returned containing the result of each time analyser was run.
    
    Parameters:
    ---
    **filename: *str* **  
    Name of the COLVAR file which contains the original sim and restarted sim

    **steps: *int* **  
    Number of steps which the restarted simulation ran for.

    **diff_steps: *int* **  
    How often to dump the histogram data, defined in number of steps

    **meta_file: *pl_file* **  
    The plumed_file object which was used to perform metadynamics

    **histo_file: *pl_file* **  
    The plumed_file object which will be used to create the histograms

    **analyser: *callable, optional* **  
    The function which will be run on each histogram to analyse it, and whose output is stored in `output`

    **extra: *int, optional* **  
    The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.  
    For example extra=10 would include the final 10 steps of the original simulation.

    **max_modifier: *int, optional* **  
    The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.

    Returns:
    ---
    **output: *list* **  
    A list containing the results of running `analyser` on each histogram&#34;&#34;&#34;
    
    start, end = create_histos(filename, steps, diff_steps, meta_file, histo_file, extra=extra)

    output = []
    count = 0
    
    if not extra:
        histogram = import_histo(&#34;histo&#34;)
        output.append(analyser(histogram))
        
    if clean_up:
        os.remove(&#34;histo&#34;)
    for i in range(0, end+1):    
        if i &gt;= start:
            histogram = import_histo(f&#34;analysis.{i}.histo&#34;)
            output.append(analyser(histogram))  
        if clean_up:
            os.remove(f&#34;analysis.{i}.histo&#34;)
    return output</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="plumed_helpers.analyse_pd"><code class="name flex">
<span>def <span class="ident">analyse_pd</span></span>(<span>filename, steps, diff_steps, meta_file, histo_file, analyser=&lt;function &lt;lambda&gt;&gt;, extra=0, clean_up=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the probability densities at set intervals over a simulation, then analyses these probability densities.
A list is returned containing the result of each time analyser was run.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>filename: <em>str</em> </strong><br>
Name of the COLVAR file which contains the original sim and restarted sim</p>
<p><strong>steps: <em>int</em> </strong><br>
Number of steps which the restarted simulation ran for.</p>
<p><strong>diff_steps: <em>int</em> </strong><br>
How often to dump the histogram data, defined in number of steps</p>
<p><strong>meta_file: <em>pl_file</em> </strong><br>
The plumed_file object which was used to perform metadynamics</p>
<p><strong>histo_file: <em>pl_file</em> </strong><br>
The plumed_file object which will be used to create the histograms</p>
<p><strong>analyser: <em>callable, optional</em> </strong><br>
The function which will be run on each histogram to analyse it, and whose output is stored in <code>output</code></p>
<p><strong>extra: <em>int, optional</em> </strong><br>
The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.<br>
For example extra=10 would include the final 10 steps of the original simulation.</p>
<p><strong>max_modifier: <em>int, optional</em> </strong><br>
The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.</p>
<h2 id="returns">Returns:</h2>
<p><strong>output: <em>list</em> </strong><br>
A list containing the results of running <code>analyser</code> on each histogram</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyse_pd(filename, steps, diff_steps, meta_file, histo_file, analyser=lambda x:x, extra=0, clean_up=True):
    &#34;&#34;&#34;Computes the probability densities at set intervals over a simulation, then analyses these probability densities. 
    A list is returned containing the result of each time analyser was run.
    
    Parameters:
    ---
    **filename: *str* **  
    Name of the COLVAR file which contains the original sim and restarted sim

    **steps: *int* **  
    Number of steps which the restarted simulation ran for.

    **diff_steps: *int* **  
    How often to dump the histogram data, defined in number of steps

    **meta_file: *pl_file* **  
    The plumed_file object which was used to perform metadynamics

    **histo_file: *pl_file* **  
    The plumed_file object which will be used to create the histograms

    **analyser: *callable, optional* **  
    The function which will be run on each histogram to analyse it, and whose output is stored in `output`

    **extra: *int, optional* **  
    The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.  
    For example extra=10 would include the final 10 steps of the original simulation.

    **max_modifier: *int, optional* **  
    The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.

    Returns:
    ---
    **output: *list* **  
    A list containing the results of running `analyser` on each histogram&#34;&#34;&#34;
    
    start, end = create_histos(filename, steps, diff_steps, meta_file, histo_file, extra=extra)

    output = []
    count = 0
    
    if not extra:
        histogram = import_histo(&#34;histo&#34;)
        output.append(analyser(histogram))
        
    if clean_up:
        os.remove(&#34;histo&#34;)
    for i in range(0, end+1):    
        if i &gt;= start:
            histogram = import_histo(f&#34;analysis.{i}.histo&#34;)
            output.append(analyser(histogram))  
        if clean_up:
            os.remove(f&#34;analysis.{i}.histo&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="plumed_helpers.create_histos"><code class="name flex">
<span>def <span class="ident">create_histos</span></span>(<span>filename, steps, diff_steps, meta_file, histo_file, extra=0, max_modifier=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates histograms from a simulation which was restarted from another simulation, dumping the historgram data periodically.<br>
The histograms are named by plumed using the format analysis.{i}.filename, where filename is specified in <code>histo_file</code> and {i} is a number indicating this is the i'th histogram created</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>filename: <em>str</em> </strong><br>
Name of the COLVAR file which contains the original sim and restarted sim</p>
<p><strong>steps: <em>int</em> </strong><br>
Number of steps which the restarted simulation ran for.</p>
<p><strong>diff_steps: <em>int</em> </strong>
How often to dump the histogram data, defined in number of steps</p>
<p><strong>meta_file: <em>pl_file</em> </strong><br>
The plumed_file object which was used to perform metadynamics</p>
<p><strong>histo_file: <em>pl_file</em> </strong><br>
The plumed_file object which will be used to create the histograms</p>
<p><strong>extra: <em>int, optional</em> </strong><br>
The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.<br>
For example extra=10 would include the final 10 steps of the original simulation.</p>
<p><strong>max_modifier: <em>int, optional</em> </strong><br>
The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.</p>
<h2 id="returns">Returns:</h2>
<p><strong>start_num: <em>int</em> </strong><br>
An integer which signifies the number in the filename of the first histogram pertaining to the restarted simulation. This will be 0 if extra is not specified</p>
<p><strong>end_num: <em>int</em> </strong><br>
An integer which signifies the number in the filename of the final histogram pertaining to the restarted simulation. This is also the total number of histograms created</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_histos(filename, steps, diff_steps, meta_file, histo_file, extra=0, max_modifier=1):
    &#34;&#34;&#34;Creates histograms from a simulation which was restarted from another simulation, dumping the historgram data periodically.  
    The histograms are named by plumed using the format analysis.{i}.filename, where filename is specified in `histo_file` and {i} is a number indicating this is the i&#39;th histogram created

    Parameters:
    ---
    **filename: *str* **  
    Name of the COLVAR file which contains the original sim and restarted sim

    **steps: *int* **  
    Number of steps which the restarted simulation ran for.

    **diff_steps: *int* **
    How often to dump the histogram data, defined in number of steps

    **meta_file: *pl_file* **  
    The plumed_file object which was used to perform metadynamics

    **histo_file: *pl_file* **  
    The plumed_file object which will be used to create the histograms

    **extra: *int, optional* **  
    The number of steps worth of additional data to use from the original simulation when compiling the histograms. Counts from the end of the simulation backwards.  
    For example extra=10 would include the final 10 steps of the original simulation.

    **max_modifier: *int, optional* **  
    The maximum number of backups plumed is allowed to created is multiplied by this amount. Useful if one intends to call plumed_histo() multiple times.

    Returns:
    ---
    **start_num: *int* **  
    An integer which signifies the number in the filename of the first histogram pertaining to the restarted simulation. This will be 0 if extra is not specified

    **end_num: *int* **  
    An integer which signifies the number in the filename of the final histogram pertaining to the restarted simulation. This is also the total number of histograms created&#34;&#34;&#34;
    
    with open(filename, &#39;r&#39;) as file:
        data = file.readlines()

    meta_stride = meta_file.get_arg(&#39;STRIDE&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;])
    meta_stride = int(meta_stride.split(&#39;=&#39;)[1])
    
    lines = round(steps/meta_stride) # Number of lines in COLVAR file
    diff_stride = round(diff_steps/meta_stride) # Stride to use in histo_file
    file_num = int(lines/diff_stride) # Number of relevant files that will be generated
    
    extra_lines = round(extra/meta_stride)
    total_files = int((lines+extra_lines)/diff_stride) # Total number of generated files
    
    if extra_lines + lines &gt; len(data)-2:
        raise Exception(f&#34;Error: The number of lines requested {extra_lines + lines} is greater than the length of the provided file {len(data)-2}&#34;)
    
    del data[1:len(data)-lines-extra_lines-2]
    
    # Writing simulation of interest into its own file for running plumed on it
    with open(&#34;COLVAR_temp&#34;, &#34;w+&#34;) as file:
        file.writelines(data)
    
    # Creating histograms for the simulation of interest
    histo_file.modify_line(&#39;STRIDE&#39;, str(diff_stride), descriptors=[&#39;action_single&#39;, &#39;DUMPGRID&#39;])
    histo_file.save()
    plumed_histo(histo_file.filename, maxbackup=total_files*max_modifier, out=False)
    
    os.remove(&#34;COLVAR_temp&#34;) # Cleanup
    
    start_num = total_files - file_num - 1
    end_num = total_files - 2
    return start_num, end_num # The number in the filename of the first and last relevant (i.e. pertaining to the restarted simulation) files </code></pre>
</details>
</dd>
<dt id="plumed_helpers.import_histo"><code class="name flex">
<span>def <span class="ident">import_histo</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads in a histogram file, normalises the values and returns a numpy float array</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>filename: <em>str</em> </strong><br>
The name of the histogram file to read</p>
<h2 id="returns">Returns:</h2>
<p><strong>data: <em>ndarray</em> </strong> <br>
An array containing all of the histograms data</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_histo(filename):
    &#34;&#34;&#34;Reads in a histogram file, normalises the values and returns a numpy float array

    Parameters:
    ---
    **filename: *str* **  
    The name of the histogram file to read

    Returns:
    ---
    **data: *ndarray* **   
    An array containing all of the histograms data&#34;&#34;&#34;
    
    with open(filename, &#39;r&#39;) as file:
        data = file.readlines()
    normalisation = float(data[1].split()[3])
    data = data[6:]
    for i in range(len(data)):
        data[i] = [float(num) for num in data[i].split()]
    data = np.array(data)
    data[:,1] = data[:,1]/normalisation
    return data</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_histo"><code class="name flex">
<span>def <span class="ident">plumed_histo</span></span>(<span>filename, maxbackup=100, out=True)</span>
</code></dt>
<dd>
<section class="desc"><p>For running a plumed script which creates histograms.<br>
Has options to set <code>maxbackup</code> which is usually needed when creating many files.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>filename: <em>str</em> </strong><br>
The name of the plumed data file to use</p>
<p><strong>maxbackup: <em>int, optional</em> </strong><br>
The maximum amount of backups and hence files plumed is allowed to create</p>
<p><strong>out: <em>bool, optional</em> </strong><br>
When set to True the function will print its output (what would normally appear in the shell).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plumed_histo(filename, maxbackup=100, out=True):
    &#34;&#34;&#34;For running a plumed script which creates histograms.  
    Has options to set `maxbackup` which is usually needed when creating many files.

    Parameters:
    ---
    **filename: *str* **  
    The name of the plumed data file to use

    **maxbackup: *int, optional* **  
    The maximum amount of backups and hence files plumed is allowed to create

    **out: *bool, optional* **  
    When set to True the function will print its output (what would normally appear in the shell).&#34;&#34;&#34;
    
    bashCommand = f&#34;plumed --no-mpi driver --plumed {filename} --noatoms&#34;
    env_set = f&#39;export PLUMED_MAXBACKUP={maxbackup}&#39;
    normal = subprocess.run(env_set + &#39;; &#39; + bashCommand,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        check=True,
        text=True,
        shell=True
        )

    if out:
        print(normal.stdout)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="plumed_helpers.plumed_file"><code class="flex name class">
<span>class <span class="ident">plumed_file</span></span>
<span>(</span><span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Parses and stores a plumed data file for manipulation</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>filename: <em>str</em> </strong>
The name of the plumed data file to parse</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class plumed_file:
    &#34;&#34;&#34;Parses and stores a plumed data file for manipulation
    
    Parameters:
    ---
    **filename: *str* **
    The name of the plumed data file to parse&#34;&#34;&#34;
    
    def __init__(self, filename):
        self.filename = filename
        with open(filename, &#39;r&#39;) as file:
            data = file.readlines()
            self.data = self.parser(data)
            
    def parser(self, data):
        &#34;&#34;&#34;
        Parses file into a 2d array where rows correspond to lines in the file and columns contain a description of the line, its name and its contents. 

        Parameters:
        ---
        **filename: *str* **  
        The name of the histogram file to read

        Returns:
        ---
        **data: *ndarray* **   
        An array containing all of the histograms data parsed and formatted
        
        Notes
        ---
        Once a file is parsed it will generally be a 2d array of the form: [[description, name, arguements], [description, name, arguements], ...]. 
        The exact format the parser uses is detailed below.
        A line generally has the format [description, name, arguement1, arguement2, ...]. The only exception is &#39;empty&#39; lines which only contain a description.
        
        There are seven different descriptions a line can have, [&#39;action_start&#39;, &#39;action_end&#39;, &#39;action_var&#39;, &#39;action_single&#39;, &#39;variable&#39;, &#39;empty&#39;, &#39;comment&#39;].
        
        The &#39;action_start&#39; and &#39;action_end&#39; descriptions indicate the line marks the start or end of a multiline action
        .
        The &#39;action_var&#39; description indicates the line describes an arguement of a multiline action
        
        The &#39;action_single&#39; description indicates the line contains an entire action on a single line, including declaration and arguements
        
        The &#39;variable&#39; description indicates the line which stores the result of an action into a variable
        
        The &#39;empty&#39; description indicates the line contains nothing (is just for formatting)
        
        The &#39;comment&#39; description indicates the line contains only a comment and nothing else
        
        For more information on actions see the Plumed documentation
        
        The name column contains information to distinguish lines with the same description.
        
        Lines with the description &#39;action_start&#39; and &#39;action_single&#39; have the name of the action as their name column
        
        Lines with the description &#39;action_end&#39; have &#39;...&#39; in their name column
        
        Lines with the description &#39;variable&#39; have the name of the variable they&#39;re using in their name column
        
        Lines with the description &#39;comment&#39; are simply numbered in the order in which they appear, starting from 0, in their name column.
        
        Anything else on a line that is not written in the name column is placed in arguements columns. Arguements can contain several columns. Every string which is seperated by a space is placed in its own column in arguements.
        
        Examples
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following two lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        &#34;&#34;&#34;
        
        inside_action = &#39;&#39;
        
        for i in range(len(data)):
            line = data[i].strip()
            
            if not line:
                data[i] = [&#39;empty&#39;]
                continue
                
            elif &#39;#&#39; == line.split()[0]:
                data[i] = [&#39;comment&#39;, f&#39;{i}&#39;, line]
                continue
            
            elif inside_action:
                if &#39;...&#39; in line.split():
                    descriptor = &#39;action_end&#39;
                    name, args = line.split()
                    inside_action = &#39;&#39;
                    
                else:
                    descriptor = &#39;action_var&#39;
                    name, args = inside_action, line
                    
            else:
                if &#39;...&#39; in line.split():
                    descriptor = &#39;action_start&#39;
                    name, args = line.split()
                    inside_action = name
                    
                elif &#39;:&#39; in line:
                    descriptor = &#39;variable&#39;
                    name, args = line.split(&#39;:&#39;)

                else:
                    descriptor = &#39;action_single&#39;
                    name, args = line.split()[0], &#39; &#39;.join(line.split()[1:])

            args = args.strip().split()
            data[i] = [descriptor, name]
            data[i].extend(args)           
                
        return data
    
    def reparse(self):
        &#34;&#34;&#34;For use after adding data to the file, parses it to match the rest of the data.
        Modifies `self.data`.
        
        See Also
        ---
        parser: Main function used for parsing
        &#34;&#34;&#34;
        
        inside_action = &#39;&#39;
        
        for line_num in range(len(self.data)):
            line = self.data[line_num]
            if isinstance(line, str):
                if inside_action:
                    parsed_line = [&#39;action_var&#39;, inside_action, line]
                    
                else:
                    parsed_line = self.parser([line])[0]
                    
                self.data[line_num] = parsed_line
                    
            elif line[0] == &#39;action_start&#39;:
                inside_action = line[1]

            elif line[0] == &#39;action_end&#39;:
                inside_action = &#39;&#39;
                    
    def findbyname(self, descriptors):
        &#34;&#34;&#34;Finds and returns the line_number of the first line matching the given set of descriptors.
        Intended for being use by other methods.
        
        Parameters:
        ---
        **descriptors: *list* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

        Returns:
        ---
        **line_num: *int* **   
        The line number (i.e. its index in self.data) of the desired line, if a line is found
        
        **None**
        If no matching line is found, None is returned
        
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        In this example we wish to have findbyname return the third line to us (which is line number 2 when counting from 0)
        If the entire parsed line is passed to findbyname then the line number of that exact line is returned
        
        &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;])
        2
        
        However only enough information to uniquely identify the line is needed, the following also correctly identifies the line
        
        &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        2
        
        If too little information is passed then it becomes ambiguous which line is being reffered to leading to (possibly) the wrong line number being returned, as below 
        
        &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;])
        1
        
        
        &#34;&#34;&#34;
        num_d = len(descriptors)
        for line_num in range(len(self.data)):
            line = self.data[line_num]
            match = 1
            if num_d &gt; len(line):
                match = 0
            else:
                for index in range(2): # The first two descriptors, line_type and name, must match exactly
                    if descriptors[index] != line[index]:
                        match = 0
                for index in range(2, num_d): # The remaining descriptors, which are arguements of the action, use a less strict matching
                    if descriptors[index] not in line[index]:
                        match = 0
                    
            if match:
                return line_num
                
        return
                
    def modify(self, line, key, value):
        &#34;&#34;&#34;Modifies one element of a given parsed line and returns it. 
        Do not call directly, instead use the `modify_line` method
        
        Parameters:
        ---
        **line: *list* **  
        The parsed form of a line, usually directly obtained from self.data
        
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **value: *str* **  
        The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced

        Returns:
        ---
        **line: *list* **   
        The modified version of the line, with one element replaced. If `key` was not found, then this will be the original line.
        
        See Also:
        ---
        
        modify_line: A method for modifying a line based on its contents or line number
        
        &#34;&#34;&#34;
        
        for section_num in range(len(line)):
            section = line[section_num]
            if key in section:
                if &#39;=&#39; in section:
                    section = section.split(&#39;=&#39;)
                    section[1] = value
                    section = &#39;=&#39;.join(section)
                else:
                    section = value

                line[section_num] = section
                return line
        return line # If no match is found return the original line
    
    def modify_line(self, key, value, line_num=None, descriptors=None):
        &#34;&#34;&#34;Modifies an element of a line.
        The line can be found either by specifying its line number or describing its contents. This method modifies `self.data
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **value: *str* **  
        The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.modify_line(&#39;PRINT&#39;, &#39;DUMP&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;DUMP&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.modify_line(&#39;STRIDE&#39;, &#39;500&#39;, line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=500&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;DUMP&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            line = self.modify(line, key, value)
            self.data[line_num] = line
                
    def remove_line(self, line_num=None, descriptors=None):
        &#34;&#34;&#34;Remove a line specified by its line number or a description of its contents.
        
        Parameters:
        ---
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.remove_line(descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]

        &gt;&gt;&gt; file1.remove_line(line_num=1)
        &gt;&gt;&gt; file1.data        
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
        
        &#34;&#34;&#34;
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            del self.data[line_num]
        else:
            pass
        
    def remove_arg(self, key, line_num=None, descriptors=None):
        &#34;&#34;&#34;Remove an arguement from a line specified by its line number or a description of its contents. 
        The arguement is specified by its `key`, eg &#39;STRIDE&#39;. However if the key appears multiple times only the first instance will be removed. 
        If key appears as a substring in a previous arguement that arguement will be removed instead.
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to alter. This method looks for which element of the line contains `key`
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be altered.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.remove_arg(&#39;FILE&#39;, descriptors=[&#39;action_single&#39;N, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
        
        &gt;&gt;&gt; file1.remove_arg(&#39;STRIDE&#39;, line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            for section_num in range(len(line)):
                if key in line[section_num]:
                    del line[section_num]
                    self.data[line_num] = line
                    return
        else:
            pass
                
                
    def add_line(self, line, line_num=None, descriptors=None):
        &#34;&#34;&#34;Adds a line to the file so that it has a particular line number or after a line specified by a description of its contents.
        
        Parameters:
        ---
        **line: *str* **  
        A string containing the line as it would appear in the plumed data file
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following line
        
        d1: DISTANCE ATOMS=301,306
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
        
        &gt;&gt;&gt; file1.add_line(&#39;PRINT ARG=d1 STRIDE=100 FILE=COLVAR&#39;, line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.add_line(&#39;PRINT ARG=* STRIDE=100 FILE=COLVAR&#39;, descriptors=[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            if isinstance(line_num, int):
                line_num += 1
          
        if isinstance(line_num, int):
            self.data.insert(line_num, line)
            self.reparse()
            
    def add_parsed(self, line, line_num=-1, descriptors=None):
        &#34;&#34;&#34;Adds a parsed line to the file at the given line number (default at the end) or after a line specified by a description of its contents.
        
        Parameters:
        ---
        **line: *list* **  
        The parsed form of a line to be added to the file
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following line
        
        d1: DISTANCE ATOMS=301,306
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
        
        &gt;&gt;&gt; file1.add_parsed([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], line_num=1)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.add_parsed([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], descriptors=[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &#34;&#34;&#34;
          
        if descriptors:
            line_num = self.findbyname(descriptors)
            if isinstance(line_num, int):
                line_num += 1
            
        if isinstance(line_num, int):
            if line_num == -1:
                self.data.append(line_num, line)
            else:
                self.data.insert(line_num, line)
        
    def add_arg(self, arg, line_num=None, descriptors=None):
        &#34;&#34;&#34;Adds an additional arguement to a line specified by either line_number or by a description of its contents
        
        Parameters:
        ---
        **arg: *str* **  
        The arguement to be added to the line
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be added.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following line
        
        PRINT ARG=d1
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;]]
        
        &gt;&gt;&gt; file1.add_arg(&#39;STRIDE=100&#39;, line_num=0)
        &gt;&gt;&gt; file1.data
        [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
        
        &gt;&gt;&gt; file1.add_arg(&#39;FILE=COLVAR&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;])
        &gt;&gt;&gt; file1.data
        [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]

        &#34;&#34;&#34;

        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            self.data[line_num].append(arg)
            
    def get_line(self, line_num=None, descriptors=None):
        &#34;&#34;&#34;Get a line specified by its line number or by a description of its contents.
        
        Parameters:
        ---
        **line_num: *int, optional* **  
        An integer specifying the number of the line which will be retrieved.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Returns:
        ---
        **self.data[line_num]: *list* **
        The requested line in the parsed format
        
        **None**
        If no match is found
        
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;] [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.get_line(descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]

        &gt;&gt;&gt; file1.get_line(line_num=1)  
        [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]
        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            return self.data[line_num]
        else:
            return None
        
    def get_arg(self, key, line_num=None, descriptors=None):
        &#34;&#34;&#34;Get first matching arguement in a line
        
        Parameters:
        ---
        **key: *str* **  
        This indicates which element of the line to retrieve. This method looks for which element of the line contains `key`
        
        **line_num: *int, optional* **  
        An integer specifying the number of the line from which the arguement will be retrieved.
        
        **descriptors: *list, optional* **  
        `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
        
        Returns:
        ---
        **line[section_num]: *str* **
        The requested arguement
        
        **None**
        If no match is found
        
        Examples:
        ---
        In this example the file called &#39;plumed.dat&#39; contains the following three lines
        
        d1: DISTANCE ATOMS=301,306
        
        PRINT ARG=* STRIDE=100 FILE=COLVAR
        
        PRINT ARG=d1 STRIDE=100 FILE=COLVAR
        
        &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
        &gt;&gt;&gt; file1.data
        [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;] [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
        
        &gt;&gt;&gt; file1.get_arg(&#39;STRIDE&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
        &#39;STRIDE=100&#39;

        &gt;&gt;&gt; file1.get_arg(&#39;FILE&#39;, line_num=1)  
        &#39;FILE=COLVAR&#39;

        &#34;&#34;&#34;
        
        if descriptors:
            line_num = self.findbyname(descriptors)
            
        if isinstance(line_num, int):
            line = self.data[line_num]
            for section_num in range(len(line)):
                if key in line[section_num]:
                    return line[section_num]
        else:
            return None
        
    
    def save(self, filename=&#39;&#39;):
        &#34;&#34;&#34;Saves all changes to the file.
        
        Parameters:
        ---
        **filename: *str, optional* **  
        The filename to use when saving. By default overwrites the file used to create this object
        
        &#34;&#34;&#34;
        if not filename:
            filename = self.filename
            
        plain_data = []
        for line in self.data:
            line = list(line)
            if line[0] == &#39;variable&#39;:
                line[1] = line[1] + &#39;:&#39;
                
            elif line[0] == &#39;action_var&#39;:
                line[2] = &#39; &#39; + line[2]
                del line[0]
                
            del line[0]
            plain_data.append(&#39; &#39;.join(line) + &#39;\n&#39;)
        
        with open(filename, &#39;w+&#39;) as file:
            file.writelines(plain_data)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="plumed_helpers.plumed_file.add_arg"><code class="name flex">
<span>def <span class="ident">add_arg</span></span>(<span>self, arg, line_num=None, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds an additional arguement to a line specified by either line_number or by a description of its contents</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>arg: <em>str</em> </strong><br>
The arguement to be added to the line</p>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line which will be added.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following line</p>
<p>PRINT ARG=d1</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['action_single', 'PRINT', 'ARG=d1']]

&gt;&gt;&gt; file1.add_arg('STRIDE=100', line_num=0)
&gt;&gt;&gt; file1.data
[['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100']]

&gt;&gt;&gt; file1.add_arg('FILE=COLVAR', descriptors=['action_single', 'PRINT'])
&gt;&gt;&gt; file1.data
[['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_arg(self, arg, line_num=None, descriptors=None):
    &#34;&#34;&#34;Adds an additional arguement to a line specified by either line_number or by a description of its contents
    
    Parameters:
    ---
    **arg: *str* **  
    The arguement to be added to the line
    
    **line_num: *int, optional* **  
    An integer specifying the number of the line which will be added.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following line
    
    PRINT ARG=d1
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;]]
    
    &gt;&gt;&gt; file1.add_arg(&#39;STRIDE=100&#39;, line_num=0)
    &gt;&gt;&gt; file1.data
    [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
    
    &gt;&gt;&gt; file1.add_arg(&#39;FILE=COLVAR&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;])
    &gt;&gt;&gt; file1.data
    [[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]

    &#34;&#34;&#34;

    if descriptors:
        line_num = self.findbyname(descriptors)
        
    if isinstance(line_num, int):
        self.data[line_num].append(arg)</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.add_line"><code class="name flex">
<span>def <span class="ident">add_line</span></span>(<span>self, line, line_num=None, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a line to the file so that it has a particular line number or after a line specified by a description of its contents.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>line: <em>str</em> </strong><br>
A string containing the line as it would appear in the plumed data file</p>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line which will be added.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following line</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306']]

&gt;&gt;&gt; file1.add_line('PRINT ARG=d1 STRIDE=100 FILE=COLVAR', line_num=1)
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.add_line('PRINT ARG=* STRIDE=100 FILE=COLVAR', descriptors=['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'])
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_line(self, line, line_num=None, descriptors=None):
    &#34;&#34;&#34;Adds a line to the file so that it has a particular line number or after a line specified by a description of its contents.
    
    Parameters:
    ---
    **line: *str* **  
    A string containing the line as it would appear in the plumed data file
    
    **line_num: *int, optional* **  
    An integer specifying the number of the line which will be added.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following line
    
    d1: DISTANCE ATOMS=301,306
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
    
    &gt;&gt;&gt; file1.add_line(&#39;PRINT ARG=d1 STRIDE=100 FILE=COLVAR&#39;, line_num=1)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.add_line(&#39;PRINT ARG=* STRIDE=100 FILE=COLVAR&#39;, descriptors=[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;])
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    &#34;&#34;&#34;
    
    if descriptors:
        line_num = self.findbyname(descriptors)
        if isinstance(line_num, int):
            line_num += 1
      
    if isinstance(line_num, int):
        self.data.insert(line_num, line)
        self.reparse()</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.add_parsed"><code class="name flex">
<span>def <span class="ident">add_parsed</span></span>(<span>self, line, line_num=-1, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a parsed line to the file at the given line number (default at the end) or after a line specified by a description of its contents.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>line: <em>list</em> </strong><br>
The parsed form of a line to be added to the file</p>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line which will be added.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following line</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306']]

&gt;&gt;&gt; file1.add_parsed(['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR'], line_num=1)
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.add_parsed(['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], descriptors=['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'])
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parsed(self, line, line_num=-1, descriptors=None):
    &#34;&#34;&#34;Adds a parsed line to the file at the given line number (default at the end) or after a line specified by a description of its contents.
    
    Parameters:
    ---
    **line: *list* **  
    The parsed form of a line to be added to the file
    
    **line_num: *int, optional* **  
    An integer specifying the number of the line which will be added.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following line
    
    d1: DISTANCE ATOMS=301,306
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
    
    &gt;&gt;&gt; file1.add_parsed([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], line_num=1)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.add_parsed([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], descriptors=[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;])
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &#34;&#34;&#34;
      
    if descriptors:
        line_num = self.findbyname(descriptors)
        if isinstance(line_num, int):
            line_num += 1
        
    if isinstance(line_num, int):
        if line_num == -1:
            self.data.append(line_num, line)
        else:
            self.data.insert(line_num, line)</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.findbyname"><code class="name flex">
<span>def <span class="ident">findbyname</span></span>(<span>self, descriptors)</span>
</code></dt>
<dd>
<section class="desc"><p>Finds and returns the line_number of the first line matching the given set of descriptors.
Intended for being use by other methods.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>descriptors: <em>list</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="returns">Returns:</h2>
<p><strong>line_num: <em>int</em> </strong> <br>
The line number (i.e. its index in self.data) of the desired line, if a line is found</p>
<p><strong>None</strong>
If no matching line is found, None is returned</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following three lines</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<p>PRINT ARG=* STRIDE=100 FILE=COLVAR</p>
<p>PRINT ARG=d1 STRIDE=100 FILE=COLVAR</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
</code></pre>
<p>In this example we wish to have findbyname return the third line to us (which is line number 2 when counting from 0)
If the entire parsed line is passed to findbyname then the line number of that exact line is returned</p>
<pre><code>&gt;&gt;&gt; file1.findbyname(['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR'])
2
</code></pre>
<p>However only enough information to uniquely identify the line is needed, the following also correctly identifies the line</p>
<pre><code>&gt;&gt;&gt; file1.findbyname(['action_single', 'PRINT', 'ARG=d1'])
2
</code></pre>
<p>If too little information is passed then it becomes ambiguous which line is being reffered to leading to (possibly) the wrong line number being returned, as below </p>
<pre><code>&gt;&gt;&gt; file1.findbyname(['action_single', 'PRINT'])
1
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findbyname(self, descriptors):
    &#34;&#34;&#34;Finds and returns the line_number of the first line matching the given set of descriptors.
    Intended for being use by other methods.
    
    Parameters:
    ---
    **descriptors: *list* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

    Returns:
    ---
    **line_num: *int* **   
    The line number (i.e. its index in self.data) of the desired line, if a line is found
    
    **None**
    If no matching line is found, None is returned
    
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following three lines
    
    d1: DISTANCE ATOMS=301,306
    
    PRINT ARG=* STRIDE=100 FILE=COLVAR
    
    PRINT ARG=d1 STRIDE=100 FILE=COLVAR
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    In this example we wish to have findbyname return the third line to us (which is line number 2 when counting from 0)
    If the entire parsed line is passed to findbyname then the line number of that exact line is returned
    
    &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;])
    2
    
    However only enough information to uniquely identify the line is needed, the following also correctly identifies the line
    
    &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
    2
    
    If too little information is passed then it becomes ambiguous which line is being reffered to leading to (possibly) the wrong line number being returned, as below 
    
    &gt;&gt;&gt; file1.findbyname([&#39;action_single&#39;, &#39;PRINT&#39;])
    1
    
    
    &#34;&#34;&#34;
    num_d = len(descriptors)
    for line_num in range(len(self.data)):
        line = self.data[line_num]
        match = 1
        if num_d &gt; len(line):
            match = 0
        else:
            for index in range(2): # The first two descriptors, line_type and name, must match exactly
                if descriptors[index] != line[index]:
                    match = 0
            for index in range(2, num_d): # The remaining descriptors, which are arguements of the action, use a less strict matching
                if descriptors[index] not in line[index]:
                    match = 0
                
        if match:
            return line_num
            
    return</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.get_arg"><code class="name flex">
<span>def <span class="ident">get_arg</span></span>(<span>self, key, line_num=None, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get first matching arguement in a line</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>key: <em>str</em> </strong><br>
This indicates which element of the line to retrieve. This method looks for which element of the line contains <code>key</code></p>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line from which the arguement will be retrieved.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="returns">Returns:</h2>
<p><strong>line[section_num]: <em>str</em> </strong>
The requested arguement</p>
<p><strong>None</strong>
If no match is found</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following three lines</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<p>PRINT ARG=* STRIDE=100 FILE=COLVAR</p>
<p>PRINT ARG=d1 STRIDE=100 FILE=COLVAR</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'] ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.get_arg('STRIDE', descriptors=['action_single', 'PRINT', 'ARG=d1'])
'STRIDE=100'

&gt;&gt;&gt; file1.get_arg('FILE', line_num=1)  
'FILE=COLVAR'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arg(self, key, line_num=None, descriptors=None):
    &#34;&#34;&#34;Get first matching arguement in a line
    
    Parameters:
    ---
    **key: *str* **  
    This indicates which element of the line to retrieve. This method looks for which element of the line contains `key`
    
    **line_num: *int, optional* **  
    An integer specifying the number of the line from which the arguement will be retrieved.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
    
    Returns:
    ---
    **line[section_num]: *str* **
    The requested arguement
    
    **None**
    If no match is found
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following three lines
    
    d1: DISTANCE ATOMS=301,306
    
    PRINT ARG=* STRIDE=100 FILE=COLVAR
    
    PRINT ARG=d1 STRIDE=100 FILE=COLVAR
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;] [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.get_arg(&#39;STRIDE&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
    &#39;STRIDE=100&#39;

    &gt;&gt;&gt; file1.get_arg(&#39;FILE&#39;, line_num=1)  
    &#39;FILE=COLVAR&#39;

    &#34;&#34;&#34;
    
    if descriptors:
        line_num = self.findbyname(descriptors)
        
    if isinstance(line_num, int):
        line = self.data[line_num]
        for section_num in range(len(line)):
            if key in line[section_num]:
                return line[section_num]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.get_line"><code class="name flex">
<span>def <span class="ident">get_line</span></span>(<span>self, line_num=None, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a line specified by its line number or by a description of its contents.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line which will be retrieved.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="returns">Returns:</h2>
<p><strong>self.data[line_num]: <em>list</em> </strong>
The requested line in the parsed format</p>
<p><strong>None</strong>
If no match is found</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following three lines</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<p>PRINT ARG=* STRIDE=100 FILE=COLVAR</p>
<p>PRINT ARG=d1 STRIDE=100 FILE=COLVAR</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'] ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.get_line(descriptors=['action_single', 'PRINT', 'ARG=d1'])
['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']

&gt;&gt;&gt; file1.get_line(line_num=1)  
['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR']
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_line(self, line_num=None, descriptors=None):
    &#34;&#34;&#34;Get a line specified by its line number or by a description of its contents.
    
    Parameters:
    ---
    **line_num: *int, optional* **  
    An integer specifying the number of the line which will be retrieved.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
    
    Returns:
    ---
    **self.data[line_num]: *list* **
    The requested line in the parsed format
    
    **None**
    If no match is found
    
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following three lines
    
    d1: DISTANCE ATOMS=301,306
    
    PRINT ARG=* STRIDE=100 FILE=COLVAR
    
    PRINT ARG=d1 STRIDE=100 FILE=COLVAR
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;] [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.get_line(descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
    [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]

    &gt;&gt;&gt; file1.get_line(line_num=1)  
    [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]
    &#34;&#34;&#34;
    
    if descriptors:
        line_num = self.findbyname(descriptors)
        
    if isinstance(line_num, int):
        return self.data[line_num]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.modify"><code class="name flex">
<span>def <span class="ident">modify</span></span>(<span>self, line, key, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Modifies one element of a given parsed line and returns it.
Do not call directly, instead use the <code>modify_line</code> method</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>line: <em>list</em> </strong><br>
The parsed form of a line, usually directly obtained from self.data</p>
<p><strong>key: <em>str</em> </strong><br>
This indicates which element of the line to alter. This method looks for which element of the line contains <code>key</code></p>
<p><strong>value: <em>str</em> </strong><br>
The element matching <code>key</code> is replaced with <code>value</code>. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced</p>
<h2 id="returns">Returns:</h2>
<p><strong>line: <em>list</em> </strong> <br>
The modified version of the line, with one element replaced. If <code>key</code> was not found, then this will be the original line.</p>
<h2 id="see-also">See Also:</h2>
<p>modify_line: A method for modifying a line based on its contents or line number</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify(self, line, key, value):
    &#34;&#34;&#34;Modifies one element of a given parsed line and returns it. 
    Do not call directly, instead use the `modify_line` method
    
    Parameters:
    ---
    **line: *list* **  
    The parsed form of a line, usually directly obtained from self.data
    
    **key: *str* **  
    This indicates which element of the line to alter. This method looks for which element of the line contains `key`
    
    **value: *str* **  
    The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced

    Returns:
    ---
    **line: *list* **   
    The modified version of the line, with one element replaced. If `key` was not found, then this will be the original line.
    
    See Also:
    ---
    
    modify_line: A method for modifying a line based on its contents or line number
    
    &#34;&#34;&#34;
    
    for section_num in range(len(line)):
        section = line[section_num]
        if key in section:
            if &#39;=&#39; in section:
                section = section.split(&#39;=&#39;)
                section[1] = value
                section = &#39;=&#39;.join(section)
            else:
                section = value

            line[section_num] = section
            return line
    return line # If no match is found return the original line</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.modify_line"><code class="name flex">
<span>def <span class="ident">modify_line</span></span>(<span>self, key, value, line_num=None, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Modifies an element of a line.
The line can be found either by specifying its line number or describing its contents. This method modifies `self.data</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>key: <em>str</em> </strong><br>
This indicates which element of the line to alter. This method looks for which element of the line contains <code>key</code></p>
<p><strong>value: <em>str</em> </strong><br>
The element matching <code>key</code> is replaced with <code>value</code>. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced</p>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line which will be altered.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following three lines</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<p>PRINT ARG=* STRIDE=100 FILE=COLVAR</p>
<p>PRINT ARG=d1 STRIDE=100 FILE=COLVAR</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.modify_line('PRINT', 'DUMP', descriptors=['action_single', 'PRINT', 'ARG=d1'])
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'DUMP', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.modify_line('STRIDE', '500', line_num=1)
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=500', 'FILE=COLVAR'], ['action_single', 'DUMP', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify_line(self, key, value, line_num=None, descriptors=None):
    &#34;&#34;&#34;Modifies an element of a line.
    The line can be found either by specifying its line number or describing its contents. This method modifies `self.data
    
    Parameters:
    ---
    **key: *str* **  
    This indicates which element of the line to alter. This method looks for which element of the line contains `key`
    
    **value: *str* **  
    The element matching `key` is replaced with `value`. If the element contains a key-value pair e.g. STRIDE=500, then only the value will be replaced
    
    **line_num: *int, optional* **  
    An integer specifying the number of the line which will be altered.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.

    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following three lines
    
    d1: DISTANCE ATOMS=301,306
    
    PRINT ARG=* STRIDE=100 FILE=COLVAR
    
    PRINT ARG=d1 STRIDE=100 FILE=COLVAR
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.modify_line(&#39;PRINT&#39;, &#39;DUMP&#39;, descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;DUMP&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.modify_line(&#39;STRIDE&#39;, &#39;500&#39;, line_num=1)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=500&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;DUMP&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &#34;&#34;&#34;
    
    if descriptors:
        line_num = self.findbyname(descriptors)
        
    if isinstance(line_num, int):
        line = self.data[line_num]
        line = self.modify(line, key, value)
        self.data[line_num] = line</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Parses file into a 2d array where rows correspond to lines in the file and columns contain a description of the line, its name and its contents. </p>
<h2 id="parameters">Parameters:</h2>
<p><strong>filename: <em>str</em> </strong><br>
The name of the histogram file to read</p>
<h2 id="returns">Returns:</h2>
<p><strong>data: <em>ndarray</em> </strong> <br>
An array containing all of the histograms data parsed and formatted</p>
<h2 id="notes">Notes</h2>
<p>Once a file is parsed it will generally be a 2d array of the form: [[description, name, arguements], [description, name, arguements], &hellip;].
The exact format the parser uses is detailed below.
A line generally has the format [description, name, arguement1, arguement2, &hellip;]. The only exception is 'empty' lines which only contain a description.</p>
<p>There are seven different descriptions a line can have, ['action_start', 'action_end', 'action_var', 'action_single', 'variable', 'empty', 'comment'].</p>
<p>The 'action_start' and 'action_end' descriptions indicate the line marks the start or end of a multiline action
.
The 'action_var' description indicates the line describes an arguement of a multiline action</p>
<p>The 'action_single' description indicates the line contains an entire action on a single line, including declaration and arguements</p>
<p>The 'variable' description indicates the line which stores the result of an action into a variable</p>
<p>The 'empty' description indicates the line contains nothing (is just for formatting)</p>
<p>The 'comment' description indicates the line contains only a comment and nothing else</p>
<p>For more information on actions see the Plumed documentation</p>
<p>The name column contains information to distinguish lines with the same description.</p>
<p>Lines with the description 'action_start' and 'action_single' have the name of the action as their name column</p>
<p>Lines with the description 'action_end' have '&hellip;' in their name column</p>
<p>Lines with the description 'variable' have the name of the variable they're using in their name column</p>
<p>Lines with the description 'comment' are simply numbered in the order in which they appear, starting from 0, in their name column.</p>
<p>Anything else on a line that is not written in the name column is placed in arguements columns. Arguements can contain several columns. Every string which is seperated by a space is placed in its own column in arguements.</p>
<h2 id="examples">Examples</h2>
<p>In this example the file called 'plumed.dat' contains the following two lines</p>
<dl>
<dt><strong><code>d1</code></strong> :&ensp;<code>DISTANCE</code> <code>ATOMS</code>=<code>301</code>,<code>306</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>PRINT ARG=* STRIDE=100 FILE=COLVAR</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR']]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parser(self, data):
    &#34;&#34;&#34;
    Parses file into a 2d array where rows correspond to lines in the file and columns contain a description of the line, its name and its contents. 

    Parameters:
    ---
    **filename: *str* **  
    The name of the histogram file to read

    Returns:
    ---
    **data: *ndarray* **   
    An array containing all of the histograms data parsed and formatted
    
    Notes
    ---
    Once a file is parsed it will generally be a 2d array of the form: [[description, name, arguements], [description, name, arguements], ...]. 
    The exact format the parser uses is detailed below.
    A line generally has the format [description, name, arguement1, arguement2, ...]. The only exception is &#39;empty&#39; lines which only contain a description.
    
    There are seven different descriptions a line can have, [&#39;action_start&#39;, &#39;action_end&#39;, &#39;action_var&#39;, &#39;action_single&#39;, &#39;variable&#39;, &#39;empty&#39;, &#39;comment&#39;].
    
    The &#39;action_start&#39; and &#39;action_end&#39; descriptions indicate the line marks the start or end of a multiline action
    .
    The &#39;action_var&#39; description indicates the line describes an arguement of a multiline action
    
    The &#39;action_single&#39; description indicates the line contains an entire action on a single line, including declaration and arguements
    
    The &#39;variable&#39; description indicates the line which stores the result of an action into a variable
    
    The &#39;empty&#39; description indicates the line contains nothing (is just for formatting)
    
    The &#39;comment&#39; description indicates the line contains only a comment and nothing else
    
    For more information on actions see the Plumed documentation
    
    The name column contains information to distinguish lines with the same description.
    
    Lines with the description &#39;action_start&#39; and &#39;action_single&#39; have the name of the action as their name column
    
    Lines with the description &#39;action_end&#39; have &#39;...&#39; in their name column
    
    Lines with the description &#39;variable&#39; have the name of the variable they&#39;re using in their name column
    
    Lines with the description &#39;comment&#39; are simply numbered in the order in which they appear, starting from 0, in their name column.
    
    Anything else on a line that is not written in the name column is placed in arguements columns. Arguements can contain several columns. Every string which is seperated by a space is placed in its own column in arguements.
    
    Examples
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following two lines
    
    d1: DISTANCE ATOMS=301,306
    
    PRINT ARG=* STRIDE=100 FILE=COLVAR
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    &#34;&#34;&#34;
    
    inside_action = &#39;&#39;
    
    for i in range(len(data)):
        line = data[i].strip()
        
        if not line:
            data[i] = [&#39;empty&#39;]
            continue
            
        elif &#39;#&#39; == line.split()[0]:
            data[i] = [&#39;comment&#39;, f&#39;{i}&#39;, line]
            continue
        
        elif inside_action:
            if &#39;...&#39; in line.split():
                descriptor = &#39;action_end&#39;
                name, args = line.split()
                inside_action = &#39;&#39;
                
            else:
                descriptor = &#39;action_var&#39;
                name, args = inside_action, line
                
        else:
            if &#39;...&#39; in line.split():
                descriptor = &#39;action_start&#39;
                name, args = line.split()
                inside_action = name
                
            elif &#39;:&#39; in line:
                descriptor = &#39;variable&#39;
                name, args = line.split(&#39;:&#39;)

            else:
                descriptor = &#39;action_single&#39;
                name, args = line.split()[0], &#39; &#39;.join(line.split()[1:])

        args = args.strip().split()
        data[i] = [descriptor, name]
        data[i].extend(args)           
            
    return data</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.remove_arg"><code class="name flex">
<span>def <span class="ident">remove_arg</span></span>(<span>self, key, line_num=None, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove an arguement from a line specified by its line number or a description of its contents.
The arguement is specified by its <code>key</code>, eg 'STRIDE'. However if the key appears multiple times only the first instance will be removed.
If key appears as a substring in a previous arguement that arguement will be removed instead.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>key: <em>str</em> </strong><br>
This indicates which element of the line to alter. This method looks for which element of the line contains <code>key</code></p>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line which will be altered.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following three lines</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<p>PRINT ARG=* STRIDE=100 FILE=COLVAR</p>
<p>PRINT ARG=d1 STRIDE=100 FILE=COLVAR</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.remove_arg('FILE', descriptors=['action_single'N, 'PRINT', 'ARG=d1'])
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100']]

&gt;&gt;&gt; file1.remove_arg('STRIDE', line_num=1)
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100']]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_arg(self, key, line_num=None, descriptors=None):
    &#34;&#34;&#34;Remove an arguement from a line specified by its line number or a description of its contents. 
    The arguement is specified by its `key`, eg &#39;STRIDE&#39;. However if the key appears multiple times only the first instance will be removed. 
    If key appears as a substring in a previous arguement that arguement will be removed instead.
    
    Parameters:
    ---
    **key: *str* **  
    This indicates which element of the line to alter. This method looks for which element of the line contains `key`
    
    **line_num: *int, optional* **  
    An integer specifying the number of the line which will be altered.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following three lines
    
    d1: DISTANCE ATOMS=301,306
    
    PRINT ARG=* STRIDE=100 FILE=COLVAR
    
    PRINT ARG=d1 STRIDE=100 FILE=COLVAR
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.remove_arg(&#39;FILE&#39;, descriptors=[&#39;action_single&#39;N, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
    
    &gt;&gt;&gt; file1.remove_arg(&#39;STRIDE&#39;, line_num=1)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;]]
    &#34;&#34;&#34;
    
    if descriptors:
        line_num = self.findbyname(descriptors)
        
    if isinstance(line_num, int):
        line = self.data[line_num]
        for section_num in range(len(line)):
            if key in line[section_num]:
                del line[section_num]
                self.data[line_num] = line
                return
    else:
        pass</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.remove_line"><code class="name flex">
<span>def <span class="ident">remove_line</span></span>(<span>self, line_num=None, descriptors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a line specified by its line number or a description of its contents.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>line_num: <em>int, optional</em> </strong><br>
An integer specifying the number of the line which will be altered.</p>
<p><strong>descriptors: <em>list, optional</em> </strong><br>
<code>descriptors</code> is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.</p>
<h2 id="examples">Examples:</h2>
<p>In this example the file called 'plumed.dat' contains the following three lines</p>
<p>d1: DISTANCE ATOMS=301,306</p>
<p>PRINT ARG=* STRIDE=100 FILE=COLVAR</p>
<p>PRINT ARG=d1 STRIDE=100 FILE=COLVAR</p>
<pre><code>&gt;&gt;&gt; file1 = plumed_file('plumed.dat')
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR'], ['action_single', 'PRINT', 'ARG=d1', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.remove_line(descriptors=['action_single', 'PRINT', 'ARG=d1'])
&gt;&gt;&gt; file1.data
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306'], ['action_single', 'PRINT', 'ARG=*', 'STRIDE=100', 'FILE=COLVAR']]

&gt;&gt;&gt; file1.remove_line(line_num=1)
&gt;&gt;&gt; file1.data        
[['variable', 'd1', 'DISTANCE', 'ATOMS=301,306']]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_line(self, line_num=None, descriptors=None):
    &#34;&#34;&#34;Remove a line specified by its line number or a description of its contents.
    
    Parameters:
    ---
    **line_num: *int, optional* **  
    An integer specifying the number of the line which will be altered.
    
    **descriptors: *list, optional* **  
    `descriptors` is a shortened version of the parsed form of a line. It must be long enough to only match with a single line. The entire parsed line can be used.
    
    Examples:
    ---
    In this example the file called &#39;plumed.dat&#39; contains the following three lines
    
    d1: DISTANCE ATOMS=301,306
    
    PRINT ARG=* STRIDE=100 FILE=COLVAR
    
    PRINT ARG=d1 STRIDE=100 FILE=COLVAR
    
    &gt;&gt;&gt; file1 = plumed_file(&#39;plumed.dat&#39;)
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]
    
    &gt;&gt;&gt; file1.remove_line(descriptors=[&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=d1&#39;])
    &gt;&gt;&gt; file1.data
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;], [&#39;action_single&#39;, &#39;PRINT&#39;, &#39;ARG=*&#39;, &#39;STRIDE=100&#39;, &#39;FILE=COLVAR&#39;]]

    &gt;&gt;&gt; file1.remove_line(line_num=1)
    &gt;&gt;&gt; file1.data        
    [[&#39;variable&#39;, &#39;d1&#39;, &#39;DISTANCE&#39;, &#39;ATOMS=301,306&#39;]]
    
    &#34;&#34;&#34;
    if descriptors:
        line_num = self.findbyname(descriptors)
        
    if isinstance(line_num, int):
        del self.data[line_num]
    else:
        pass</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.reparse"><code class="name flex">
<span>def <span class="ident">reparse</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>For use after adding data to the file, parses it to match the rest of the data.
Modifies <code>self.data</code>.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>parser</code></dt>
<dd>Main function used for parsing</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparse(self):
    &#34;&#34;&#34;For use after adding data to the file, parses it to match the rest of the data.
    Modifies `self.data`.
    
    See Also
    ---
    parser: Main function used for parsing
    &#34;&#34;&#34;
    
    inside_action = &#39;&#39;
    
    for line_num in range(len(self.data)):
        line = self.data[line_num]
        if isinstance(line, str):
            if inside_action:
                parsed_line = [&#39;action_var&#39;, inside_action, line]
                
            else:
                parsed_line = self.parser([line])[0]
                
            self.data[line_num] = parsed_line
                
        elif line[0] == &#39;action_start&#39;:
            inside_action = line[1]

        elif line[0] == &#39;action_end&#39;:
            inside_action = &#39;&#39;</code></pre>
</details>
</dd>
<dt id="plumed_helpers.plumed_file.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename='')</span>
</code></dt>
<dd>
<section class="desc"><p>Saves all changes to the file.</p>
<h2 id="parameters">Parameters:</h2>
<p><strong>filename: <em>str, optional</em> </strong><br>
The filename to use when saving. By default overwrites the file used to create this object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename=&#39;&#39;):
    &#34;&#34;&#34;Saves all changes to the file.
    
    Parameters:
    ---
    **filename: *str, optional* **  
    The filename to use when saving. By default overwrites the file used to create this object
    
    &#34;&#34;&#34;
    if not filename:
        filename = self.filename
        
    plain_data = []
    for line in self.data:
        line = list(line)
        if line[0] == &#39;variable&#39;:
            line[1] = line[1] + &#39;:&#39;
            
        elif line[0] == &#39;action_var&#39;:
            line[2] = &#39; &#39; + line[2]
            del line[0]
            
        del line[0]
        plain_data.append(&#39; &#39;.join(line) + &#39;\n&#39;)
    
    with open(filename, &#39;w+&#39;) as file:
        file.writelines(plain_data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="plumed_helpers.analyse_pd" href="#plumed_helpers.analyse_pd">analyse_pd</a></code></li>
<li><code><a title="plumed_helpers.create_histos" href="#plumed_helpers.create_histos">create_histos</a></code></li>
<li><code><a title="plumed_helpers.import_histo" href="#plumed_helpers.import_histo">import_histo</a></code></li>
<li><code><a title="plumed_helpers.plumed_histo" href="#plumed_helpers.plumed_histo">plumed_histo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="plumed_helpers.plumed_file" href="#plumed_helpers.plumed_file">plumed_file</a></code></h4>
<ul class="two-column">
<li><code><a title="plumed_helpers.plumed_file.add_arg" href="#plumed_helpers.plumed_file.add_arg">add_arg</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.add_line" href="#plumed_helpers.plumed_file.add_line">add_line</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.add_parsed" href="#plumed_helpers.plumed_file.add_parsed">add_parsed</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.findbyname" href="#plumed_helpers.plumed_file.findbyname">findbyname</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.get_arg" href="#plumed_helpers.plumed_file.get_arg">get_arg</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.get_line" href="#plumed_helpers.plumed_file.get_line">get_line</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.modify" href="#plumed_helpers.plumed_file.modify">modify</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.modify_line" href="#plumed_helpers.plumed_file.modify_line">modify_line</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.parser" href="#plumed_helpers.plumed_file.parser">parser</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.remove_arg" href="#plumed_helpers.plumed_file.remove_arg">remove_arg</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.remove_line" href="#plumed_helpers.plumed_file.remove_line">remove_line</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.reparse" href="#plumed_helpers.plumed_file.reparse">reparse</a></code></li>
<li><code><a title="plumed_helpers.plumed_file.save" href="#plumed_helpers.plumed_file.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>